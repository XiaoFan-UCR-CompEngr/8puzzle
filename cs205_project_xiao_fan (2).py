# -*- coding: utf-8 -*-
"""CS205 project Xiao Fan.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1Wly8C43BrHT8OUGEnZM18Gwb3Ll9sWxt
"""

def print_puzzle(puzzle):
    """Prints the puzzle state in a 3x3 grid format."""
    for row in puzzle:
        print(' '.join(str(tile) for tile in row))

def is_valid_puzzle(puzzle):
    """Validates if the provided puzzle is a correctly formed 3x3 grid for the 8-puzzle."""
    if not isinstance(puzzle, list) or len(puzzle) != 3:
        return False, "Puzzle must be a list of three rows."

    tile_set = set()
    for row in puzzle:
        if not isinstance(row, list) or len(row) != 3:
            return False, "Each row of the puzzle must have exactly three tiles."

        for tile in row:
            if not isinstance(tile, int):
                return False, "Each tile must be an integer."

            if tile < 0 or tile > 8:
                return False, "Tiles must be integers between 0 and 8."

            if tile in tile_set:
                return False, "Each tile number must appear exactly once."
            tile_set.add(tile)

    if len(tile_set) != 9:
        return False, "All tiles from 0 to 8 must be present exactly once."

    return True, "The puzzle is valid."

def is_goal(puzzle):
    """Checks if the current puzzle state matches the goal state."""
    goal_state = [
        [1, 2, 3],
        [4, 5, 6],
        [7, 8, 0]
    ]
    return puzzle == goal_state

def h_misplaced(puzzle):
    """Calculates the heuristic based on the number of misplaced tiles."""
    goal_state = [
        [1, 2, 3],
        [4, 5, 6],
        [7, 8, 0]
    ]
    count = 0
    for i in range(3):
        for j in range(3):
            if puzzle[i][j] != goal_state[i][j]:
                count += 1
    return count


initial_state = [
    [1, 2, 3],
    [4, 0, 5],  # 0 represents the blank space
    [6, 7, 8]
]

goal_state = [
    [1, 2, 3],
    [4, 5, 6],
    [7, 8, 0]
]
invalid_puzzle = [
    [1,2,3],
    [4,5],
    [6,7,8,9]

]

# Testing the functions
print("Initial Puzzle State:")
print_puzzle(initial_state)
print("Is the initial state the goal state? ", "Yes" if is_goal(initial_state) else "No")
print("Number of misplaced tiles: ", h_misplaced(initial_state))
is_valid_puzzle(invalid_puzzle)

def manhattan_distance(puzzle):
    """Calculates the total Manhattan distance of all tiles from their goal positions."""
    goal_positions = {
        1: (0, 0), 2: (0, 1), 3: (0, 2),
        4: (1, 0), 5: (1, 1), 6: (1, 2),
        7: (2, 0), 8: (2, 1), 0: (2, 2)
    }
    total_distance = 0
    for i in range(3):
        for j in range(3):
            tile = puzzle[i][j]
            if tile != 0:  # Do not calculate distance for the blank space
                goal_x, goal_y = goal_positions[tile]
                total_distance += abs(i - goal_x) + abs(j - goal_y)
    return total_distance

# Example usage
puzzle = [
    [2, 8, 3],
    [1, 6, 4],
    [7, 0, 5]
]

print("Manhattan Distance:", manhattan_distance(puzzle))

def goal_test(puzzle):
    goal_state = [
        [1, 2, 3],
        [4, 5, 6],
        [7, 8, 0]
    ]
    return puzzle == goal_state

import copy
def find_blank(puzzle):
    """Find the position of the blank space (0) in the puzzle."""
    for i in range(3):
        for j in range(3):
            if puzzle[i][j] == 0:
                return i, j
    return None  # Just for safety, though the blank space should always exist

def generate_possible_moves(puzzle):
    """Generate all possible states resulting from moving the blank."""
    x, y = find_blank(puzzle)
    directions = {
        'up': (x - 1, y),
        'down': (x + 1, y),
        'left': (x, y - 1),
        'right': (x, y + 1)
    }
    valid_states = []

    for direction, (new_x, new_y) in directions.items():
        if 0 <= new_x and new_x < 3 and 0 <= new_y and new_y < 3:  # Check if the new position is within bounds
            # Create a new state by swapping the blank space with the adjacent tile
            new_puzzle = copy.deepcopy(puzzle)# without using deepcopy, the change will affact original state  # Deep copy of the puzzle
            new_puzzle[x][y], new_puzzle[new_x][new_y] = new_puzzle[new_x][new_y], new_puzzle[x][y] #Simple swap
            valid_states.append(new_puzzle) #add to the list

    return valid_states
def manhattan_distance(puzzle):
    """Calculates the total Manhattan distance of all tiles from their goal positions."""
    goal_positions = {
        1: (0, 0), 2: (0, 1), 3: (0, 2),
        4: (1, 0), 5: (1, 1), 6: (1, 2),
        7: (2, 0), 8: (2, 1), 0: (2, 2)
    }
    total_distance = 0
    for i in range(3):
        for j in range(3):
            tile = puzzle[i][j]
            if tile != 0:  # Do not calculate distance for the blank space
                goal_x, goal_y = goal_positions[tile]
                total_distance += abs(i - goal_x) + abs(j - goal_y)
    return total_distance
def print_puzzle(puzzle):
    """Prints the puzzle state in a 3x3 grid format."""
    for row in puzzle:
        print(' '.join(str(tile) for tile in row))

def is_valid_puzzle(puzzle):
    """Validates if the provided puzzle is a correctly formed 3x3 grid for the 8-puzzle."""
    if not isinstance(puzzle, list) or len(puzzle) != 3:
        return False, "Puzzle must be a list of three rows."

    tile_set = set()
    for row in puzzle:
        if not isinstance(row, list) or len(row) != 3:
            return False, "Each row of the puzzle must have exactly three tiles."

        for tile in row:
            if not isinstance(tile, int):
                return False, "Each tile must be an integer."

            if tile < 0 or tile > 8:
                return False, "Tiles must be integers between 0 and 8."

            if tile in tile_set:
                return False, "Each tile number must appear exactly once."
            tile_set.add(tile)

    if len(tile_set) != 9:
        return False, "All tiles from 0 to 8 must be present exactly once."

    return True, "The puzzle is valid."

def h_misplaced(puzzle):
    """Calculates the heuristic based on the number of misplaced tiles."""
    goal_state = [
        [1, 2, 3],
        [4, 5, 6],
        [7, 8, 0]
    ]
    count = 0
    for i in range(3):
        for j in range(3):
            if puzzle[i][j] != goal_state[i][j]:
                count += 1
    return count

# Test puzzles
easy_puzzle = [
    [1, 2, 3],
    [4, 5, 6],
    [7, 0, 8]
] #Actual depth around 2

medium_puzzle = [
    [1, 2, 3],
    [5, 0, 6],
    [4, 7, 8]
]#Actual depth around 4

hard_puzzle = [
    [1, 2, 3],
    [4, 0, 5],
    [6, 7, 8]
]#Actual depth around 16

hard_puzzle2 = [
    [5, 2, 8],
    [4, 1, 7],
    [0, 3, 6]
]#Actual depth around 23

import heapq
import copy

def uniform_cost_search(initial_state, goal_test, find_successors):
    frontier = [(0, initial_state, [])]  # Priority queue with cost, state, and path
    explored = set()
    nodes_expanded = 0  # Count nodes expanded

    while frontier:
        cost, current, path = heapq.heappop(frontier)
        nodes_expanded += 1  # Increment on processing each node

        if goal_test(current):
            return current, cost, path + [current], nodes_expanded  # Include current in path

        current_tuple = tuple(map(tuple, current))  # Convert to tuple for hashing
        if current_tuple not in explored:
            explored.add(current_tuple)
            successors = find_successors(current)
            for successor in successors:
                new_path = path + [current]  # Append current state to path
                heapq.heappush(frontier, (cost + 1, successor, new_path))

    return None, None, [], nodes_expanded  # No solution found

# Test Uniform Cost Search
def test_uniform_cost_search(puzzle_input):
    print("Testing Uniform Cost Search...")
    current_puzzle = puzzle_input
    print("Current Puzzle:")
    print_puzzle(current_puzzle)
    print("\nPossible Moves:")
    for state in generate_possible_moves(current_puzzle):
        print_puzzle(state)
        print("---")

    result, cost, path, nodes_expanded = uniform_cost_search(current_puzzle, is_goal, generate_possible_moves)
    print("\nSolution Path:")
    for step in path:
        print_puzzle(step)
        print("---")
    print("Total moves: ", len(path) - 1)  # Subtract 1 because the initial state is part of the path
    print("Total nodes expanded: ", nodes_expanded)

test_uniform_cost_search(hard_puzzle)

import heapq
import copy

def a_star_search_misplaced(initial_state, goal_test, find_successors, heuristic):
    frontier = [(heuristic(initial_state), 0, initial_state, [])]  # (f(n), g(n), state, path)
    explored = set()
    nodes_expanded = 0

    while frontier:
        f_n, g_n, current, path = heapq.heappop(frontier)
        nodes_expanded += 1

        if goal_test(current):
            return current, g_n, path + [current], nodes_expanded  # Include current in path

        current_tuple = tuple(map(tuple, current))
        if current_tuple not in explored:
            explored.add(current_tuple)
            successors = find_successors(current)
            for successor in successors:
                g_n_successor = g_n + 1  # Increment the path cost
                h_n_successor = heuristic(successor)
                f_n_successor = g_n_successor + h_n_successor
                heapq.heappush(frontier, (f_n_successor, g_n_successor, successor, path + [current]))

    return None, None, [], nodes_expanded  # No solution found

# Test A* Search with Misplaced Tile Heuristic
def test_a_star_misplaced(puzzle_input):
    print("Testing A* Search with Misplaced Tile Heuristic...")
    current_puzzle = puzzle_input
    print("Current Puzzle:")
    print_puzzle(current_puzzle)
    print("\nPossible Moves:")
    for state in generate_possible_moves(current_puzzle):
        print_puzzle(state)
        print("---")

    result, cost, path, nodes_expanded = a_star_search_misplaced(current_puzzle, is_goal, generate_possible_moves, h_misplaced)
    print("\nSolution Path:")
    for step in path:
        print_puzzle(step)
        print("---")
    print("Total moves: ", len(path) - 1)  # Subtract 1 because the initial state is part of the path
    print("Total nodes expanded: ", nodes_expanded)


test_a_star_misplaced(medium_puzzle)

import heapq
import copy

def a_star_search_manhattan(initial_state, goal_test, find_successors, heuristic):
    frontier = [(heuristic(initial_state), 0, initial_state, [])]  # (f(n), g(n), state, path)
    explored = set()
    nodes_expanded = 0

    while frontier:
        f_n, g_n, current, path = heapq.heappop(frontier)
        nodes_expanded += 1  # Increment the node expanded counter

        if goal_test(current):
            return current, g_n, path + [current], nodes_expanded  # Include the current state in the path

        current_tuple = tuple(map(tuple, current))
        if current_tuple not in explored:
            explored.add(current_tuple)
            successors = find_successors(current)
            for successor in successors:
                g_n_successor = g_n + 1  # Increment the path cost by 1 for each move
                h_n_successor = heuristic(successor)
                f_n_successor = g_n_successor + h_n_successor
                heapq.heappush(frontier, (f_n_successor, g_n_successor, successor, path + [current]))

    return None, None, [], nodes_expanded  # No solution found if loop exits

# Test A* Search with Manhattan Distance Heuristic
def test_a_star_manhattan(puzzle_input):
    print("Testing A* Search with Manhattan Distance Heuristic...")
    current_puzzle = puzzle_input
    print("Current Puzzle:")
    #print_puzzle(current_puzzle)
    #print("\nPossible Moves:")
    for state in generate_possible_moves(current_puzzle):
        print_puzzle(state)
        print("---")

    result, cost, path, nodes_expanded = a_star_search_manhattan(current_puzzle, is_goal, generate_possible_moves, manhattan_distance)
    print("\nSolution Path:")
    for step in path:
        print_puzzle(step)
        print("---")
    print("Total moves: ", len(path) - 1)  # Subtract 1 because the initial state is part of the path
    print("Total nodes expanded: ", nodes_expanded)


test_a_star_manhattan(medium_puzzle)

puzzle_depths = {
    "Easy Puzzle": 2,
    "Medium Puzzle": 4,
    "Hard Puzzle": 16,
    "Very Hard Puzzle": 23
}

import matplotlib.pyplot as plt

def run_tests():
    puzzles = {
        "Easy Puzzle": easy_puzzle,
        "Medium Puzzle": medium_puzzle,
        "Hard Puzzle": hard_puzzle,
        "Very Hard Puzzle": hard_puzzle2
    }
    methods = {
        "Uniform Cost Search": lambda p: uniform_cost_search(p, is_goal, generate_possible_moves),
        "A* Misplaced Tile": lambda p: a_star_search_misplaced(p, is_goal, generate_possible_moves, h_misplaced),
        "A* Manhattan Distance": lambda p: a_star_search_manhattan(p, is_goal, generate_possible_moves, manhattan_distance)
    }

    results = {name: {} for name in methods.keys()}

    # Running the tests
    for puzzle_name, puzzle in puzzles.items():
        print(f"\nTesting {puzzle_name}")
        for method_name, method in methods.items():
            print(f"  Using {method_name}")
            _, cost, path, nodes_expanded = method(puzzle)
            results[method_name][puzzle_name] = {
                "cost": cost,
                "path_length": len(path),
                "nodes_expanded": nodes_expanded
            }

    # Plotting results
    fig, ax = plt.subplots(1, 2, figsize=(14, 6))

    # Nodes expanded comparison
    depths = [puzzle_depths[name] for name in puzzles]  # Extracting depths for the x-axis
    for method_name in methods:
        nodes = [results[method_name][puzzle_name]["nodes_expanded"] for puzzle_name in puzzles]
        ax[0].plot(depths, nodes, marker='o', label=method_name)

    ax[0].set_title('Comparison of Nodes Expanded')
    ax[0].set_xlabel('Actual Depth of Puzzle')
    ax[0].set_ylabel('Nodes Expanded')
    ax[0].legend()

    # Path length comparison
    for method_name in methods:
        path_lengths = [results[method_name][puzzle_name]["path_length"] for puzzle_name in puzzles]
        ax[1].plot(depths, path_lengths, marker='o', label=method_name)

    ax[1].set_title('Comparison of Solution Path Length')
    ax[1].set_xlabel('Actual Depth of Puzzle')
    ax[1].set_ylabel('Path Length')
    ax[1].legend()

    plt.show()

run_tests()

import matplotlib.pyplot as plt

def run_zoomed_in_tests():
    puzzles = {
        "Easy Puzzle": easy_puzzle,
        "Medium Puzzle": medium_puzzle,
        "Hard Puzzle": hard_puzzle,
        "Very Hard Puzzle": hard_puzzle2
    }
    methods = {
        "A* Misplaced Tile": lambda p: a_star_search_misplaced(p, is_goal, generate_possible_moves, h_misplaced),
        "A* Manhattan Distance": lambda p: a_star_search_manhattan(p, is_goal, generate_possible_moves, manhattan_distance)
    }

    results = {name: {} for name in methods.keys()}

    # Running the tests
    for puzzle_name, puzzle in puzzles.items():
        for method_name, method in methods.items():
            _, _, _, nodes_expanded = method(puzzle)
            results[method_name][puzzle_name] = nodes_expanded

    # Plotting results
    fig, ax = plt.subplots(figsize=(8, 6))

    # Nodes expanded comparison
    puzzle_names = list(puzzles.keys())
    puzzle_depths = [2, 4, 16, 23]  # Actual depths as previously defined
    for method_name in methods:
        nodes = [results[method_name][puzzle_name] for puzzle_name in puzzles]
        ax.plot(puzzle_depths, nodes, marker='o', label=method_name)

    ax.set_title('Detailed Comparison of Nodes Expanded by A* Heuristics')
    ax.set_xlabel('Actual Depth of Puzzle')
    ax.set_ylabel('Nodes Expanded')
    ax.legend()

    # Setting the y-axis limits to zoom in more closely on the data
    ax.set_ylim(0, max(max(results["A* Misplaced Tile"].values()), max(results["A* Manhattan Distance"].values())) * 1.1)  # Adjust y limit

    plt.show()

run_zoomed_in_tests()